import tw from "@/tailwind";
import { useRouter } from "expo-router";
import { useEffect, useState, useRef } from "react";
import { ActivityIndicator, Text, TouchableOpacity, View } from "react-native";
import { Booking, getRealTicketStatus, isTicketClickable } from "../mestickets";
import TicketContent from "./ticketContent";
import { supabaseClient } from "@/lib/supabase";
import { RealtimeChannel } from "@supabase/supabase-js";
import NetInfo from '@react-native-community/netinfo';

interface Ticket {
  id?: string;
  code?: string;
  isUpdated?: boolean;
  tickeNumber?: string;
}

// Rendu d'un ticket individuel avec √©coute temps r√©el
const RenderTicket = ({ item }: { item: Booking }) => {
  const router = useRouter();
  
  // üî• CORRECTION 1: Initialiser avec les donn√©es existantes et valeur par d√©faut pour isUpdated
  const [ticket, setTicket] = useState<Ticket | undefined>(() => {
    if (item?.ticket) {
      return {
        id: item.ticket.id,
        code: item.ticket.code,
        isUpdated: item.ticket.isUpdated ?? true, // üî• Valeur par d√©faut true si undefined
        tickeNumber: item.ticket.tickeNumber
      };
    }
    return undefined;
  });
  
  // üî• NOUVEAU: √âtat pour suivre la connectivit√©
  const [isOnline, setIsOnline] = useState(true);
  const subscriptionRef = useRef<RealtimeChannel | null>(null);

  // üî• NOUVEAU: Surveillance de la connectivit√©
  useEffect(() => {
    const unsubscribe = NetInfo.addEventListener(state => {
      setIsOnline(state.isConnected ?? false);
    });
    return unsubscribe;
  }, []);

  // R√©cup√©ration initiale des donn√©es du ticket ET √©coute temps r√©el
  useEffect(() => {
    if (!item?.ticket?.id) return;

    const fetchTicketData = async () => {
      // üî• CORRECTION 2: Ne pas faire d'appel r√©seau si hors ligne
      if (!isOnline) {
        console.log('üì∂ Hors ligne - utilisation des donn√©es cached pour ticket', item.ticket.id);
        return;
      }

      try {
        const { data } = await supabaseClient
          .from("Ticket")
          .select("id,code,isUpdated,tickeNumber")
          .eq("id", item.ticket.id)
          .maybeSingle();

        if (data) {
          setTicket({
            id: data.id,
            code: data.code,
            isUpdated: data.isUpdated ?? true, // üî• Valeur par d√©faut si undefined
            tickeNumber: data.tickeNumber
          });
        }
      } catch (error) {
        console.error("Erreur lors de la r√©cup√©ration du ticket:", error);
        // üî• CORRECTION 3: En cas d'erreur, garder les donn√©es existantes
        console.log('‚ùå Erreur r√©seau - conservation des donn√©es cached');
      }
    };

    // Nettoyage de l'abonnement pr√©c√©dent s'il existe
    if (subscriptionRef.current) {
      subscriptionRef.current.unsubscribe();
      subscriptionRef.current = null;
    }

    // R√©cup√©ration initiale seulement si en ligne
    if (isOnline) {
      fetchTicketData();

      // AJOUT: √âcoute en temps r√©el des changements sur le ticket
      const channelName = `ticket-${item.ticket.id}-${Date.now()}`;
      subscriptionRef.current = supabaseClient
        .channel(channelName)
        .on(
          'postgres_changes',
          {
            event: 'UPDATE',
            schema: 'public',
            table: 'Ticket',
            filter: `id=eq.${item.ticket.id}`
          },
          (payload) => {
            console.log('üîÑ Changement d√©tect√© sur le ticket:', payload);
            
            // Mettre √† jour l'√©tat local avec les nouvelles donn√©es
            if (payload.new) {
              setTicket(prevTicket => ({
                ...prevTicket,
                id: payload.new.id,
                code: payload.new.code,
                isUpdated: payload.new.isUpdated ?? true, // üî• Valeur par d√©faut
                tickeNumber: payload.new.tickeNumber
              }));
            }
          }
        )
        .subscribe();
    } else {
      console.log('üì∂ Hors ligne - pas d\'abonnement temps r√©el');
    }

    // Nettoyage de l'abonnement
    return () => {
      if (subscriptionRef.current) {
        subscriptionRef.current.unsubscribe();
        subscriptionRef.current = null;
      }
    };
  }, [item?.ticket?.id, isOnline]);

  const realStatus = getRealTicketStatus(item);
  const isExpired = realStatus === "expired";
  const clickable = isTicketClickable(item);

  // üî• CORRECTION 4: Utiliser les donn√©es cached si disponibles
  const effectiveTicket = ticket || item.ticket;

  // üî• CORRECTION 5: Logique am√©lior√©e pour shouldShowLoading
  const shouldShowLoading = () => {
    // Si hors ligne, ne jamais afficher le loading
    if (!isOnline) {
      return false;
    }
    
    // Si pas de donn√©es du tout, afficher le loading
    if (!effectiveTicket) {
      return true;
    }
    
    // Si isUpdated est explicitement false, afficher le loading
    if (effectiveTicket.isUpdated === false) {
      return true;
    }
    
    // Dans tous les autres cas, ne pas afficher le loading
    return false;
  };

  // üî• CORRECTION 6: Nouvelle logique pour isTicketReady
  const isTicketReady = () => {
    // Si pas de ticket, pas pr√™t
    if (!effectiveTicket) {
      return false;
    }
    
    // Si hors ligne, utiliser les donn√©es cached (toujours pr√™t)
    if (!isOnline) {
      return true;
    }
    
    // Si en ligne, v√©rifier isUpdated
    // Si isUpdated est true ou undefined, pr√™t
    // Si isUpdated est false, pas pr√™t (en cours de mise √† jour)
    return effectiveTicket.isUpdated !== false;
  };

  // üî• LOGS DE DEBUG
  // console.log('üîç DEBUG TICKET:', {
  //   ticketId: item?.ticket?.id,
  //   isOnline,
  //   effectiveTicket: effectiveTicket ? {
  //     id: effectiveTicket.id,
  //     isUpdated: effectiveTicket.isUpdated,
  //     code: effectiveTicket.code
  //   } : null,
  //   shouldShowLoading: shouldShowLoading(),
  //   isTicketReady: isTicketReady(),
  //   clickable,
  //   realStatus
  // });

  // Ticket expir√©
  if (isExpired) {
    return (
      <View
        style={tw`relative bg-white rounded-xl shadow-lg mx-4 mb-4 overflow-hidden border border-gray-100 opacity-40`}
      >
        <TicketContent item={item} />
      </View>
    );
  }

  // Fonction pour calculer la date d'expiration d'un ticket
  const calculateExpirationDate = (item: Booking): Date => {
    if (item.trip?.departureTime) {
      const departureDate = new Date(item.trip.departureTime);

      let validityHours = 2; // Par d√©faut 2 heures
      const operatorName = item.operatorName || item.ticket?.operatorName || '';

      if (operatorName.toLowerCase().includes('brt') ||
        operatorName.toLowerCase().includes('rapid transit')) {
        validityHours = 1; // BRT: 1 heure
      } else if (operatorName.toLowerCase().includes('dem dikk')) {
        validityHours = 1; // Dem Dikk: 1 heure
      } else if (operatorName.toLowerCase().includes('ter')) {
        validityHours = 2; // TER: 2 heures
      }

      return new Date(departureDate.getTime() + (validityHours * 60 * 60 * 1000));
    }

    return new Date(Date.now() + (2 * 60 * 60 * 1000));
  };

  const getValidityHours = (item: Booking) => {
    const operatorName = item.operatorName || item.ticket?.operatorName || '';

    if (operatorName.toLowerCase().includes('brt') ||
      operatorName.toLowerCase().includes('rapid transit')) {
      return 1; // BRT: 1 heure
    } else if (operatorName.toLowerCase().includes('dem dikk')) {
      return 1; // Dem Dikk: 1 heure
    } else if (operatorName.toLowerCase().includes('ter')) {
      return 2; // TER: 2 heures
    }

    return 2; // Par d√©faut 2 heures
  };

  // Ticket en cours de chargement
  if (shouldShowLoading()) {
    return (
      <View
        style={tw`relative bg-white rounded-xl shadow-lg mb-4 overflow-hidden border border-gray-100 opacity-40`}
      >
        <TicketContent item={item} />
        <View
          style={tw`opacity-70 absolute bg-white h-100% items-center justify-center w-97% flex-row gap-3`}
        >
          <ActivityIndicator color="#094741" size={35} />
          <Text style={tw`text-lg font-bold text-gray-800`}>
            {isOnline ? 'Ticket en cours de chargement...' : 'Ticket disponible hors ligne'}
          </Text>
        </View>
      </View>
    );
  }

  // üî• CORRECTION 7: Utiliser la nouvelle fonction isTicketReady
  // Ticket actif : cliquable
  if (clickable && isTicketReady()) {
    const isUrbanTicket =
      item.zoneType === "SAME_ZONE" ||
      item.zoneType === "DIFFERENT_ZONES" ||
      item.zoneType === "TOUT_ZONE";
    // Correction : d√©tection souple de l'op√©rateur
    const opName = (item.operatorName || "").toLowerCase();
    const isBRT = opName.includes("brt") || opName.includes("rapid transit");
    const isTER = opName.includes("ter");
    const isDemDikk = opName.includes("dem dikk");

    return (
      <TouchableOpacity
        style={tw`bg-white rounded-xl shadow-sm mx-4 mb-4 overflow-hidden border border-gray-100`}
        onPress={() => {
          // console.log('üéØ Ticket cliqu√©:', {
          //   isUrbanTicket,
          //   operatorName: item.operatorName,
          //   ticketCode: effectiveTicket?.code
          // });
          
          if (isUrbanTicket) {
            // D√©terminer l'op√©rateur et le type pour la navigation
            let operatorName = "";
            let operatorType = "";
            let operatorLogoUrl = "";
            
            let transportType = "";

            if (isBRT) {
              operatorName = "Bus Rapid Transit";
              operatorType = "BRT";
              transportType = "BRT";
            } else if (isDemDikk) {
              operatorName = "Dem Dikk";
              operatorType = "DemDikk";
              transportType = "DemDikk";
            } else if (isTER) {
              operatorName = "TER Senegal";
              operatorType = "TER";
              transportType = "TER";
            } else {
              operatorName = item.operatorName || "Op√©rateur inconnu";
              operatorType = "INCONNU";
              transportType = "INCONNU";
            }

            // Navigation pour les tickets urbains avec classeType
            router.push({
              pathname: "/pages/TicketPage/TicketPageUrbain/ticketpages",
              params: {
                departureStation: (effectiveTicket as any)?.departureStation || (item as any).departureStation ,
                arrivalStation: (effectiveTicket as any)?.arrivalStation || (item as any).arrivalStation ,
                operatorName: operatorName|| item.operator?.name,
                operatorLogoUrl:item.operator?.logoUrl,
                 id: item.ticket?.id || "",
                operatorType: operatorType,
                transportType: transportType,
                ticketCode: effectiveTicket?.code || '',
                tickeNumber: effectiveTicket?.tickeNumber || '',
                price: item.payment?.amount || '',
                validatedAt: item.ticket?.validatedAt,
                expiresAt: item.ticket?.expiresAt,
                departurezone: item.ticket?.departurezone,
                matriculeVehicle: item.ticket?.matriculeVehicle,
                isInterZones: String(item!.isInterZones),
                status:item.ticket?.status,
                zoneType: (effectiveTicket as any)?.zoneType || (item as any).zoneType || '',
                validityHours: getValidityHours(item).toString(),
                bookingDate: item.bookingDate || item.date || '',
                transactionId: item.payment?.transactionId || '',
                classeType: item.ticket?.ticketCount?.classeType || '',
                ticketCount: item.ticket?.ticketCount?.count || 1
              }
            });
          } else {
            // Navigation pour les tickets interurbains
            const interurbainRoute = {
              pathname: "/pages/TicketPage/ticketpages",
              params: {
                departure: item.trip?.departure || "",
                destination: item.trip?.destination || "",
                date: item.trip?.departureTime || item.date || item.bookingDate || "",
                departureTime: item.trip?.departureTime || "",
                station_depart: item.trip?.station_depart || "",
                station_arrivee: item.trip?.station_arrivee || "",
                price: item.trip?.price || item.payment?.amount || 0,
                operatorName:
                  item.operatorName || item.operator?.name || item.trip?.operator?.name || "",
                  operatorLogoUrl:item.operator?.logoUrl,

                ticketNumber: item.ticket?.Number || effectiveTicket?.code || "",
                seatNumber: effectiveTicket?.tickeNumber,
                ticketCode: effectiveTicket?.code || "",
                vehicleNumber: item.trip?.vehicle?.registrationNumber || "",
                registrationNumber: item.trip?.vehicle?.registrationNumber || "",
                vehicleData: JSON.stringify(item.trip?.vehicle) || "{}",
                passengerName:
                  item.passengers && item.passengers.length > 0 ? item.passengers[0].name : "",
                passengerPhone:
                  item.passengers && item.passengers.length > 0 ? item.passengers[0].phoneNumber : "",
              },
            };

            // console.log("Navigation vers route interurbain :", interurbainRoute);
            router.push(interurbainRoute as any);
          }
        }}
      >
        <TicketContent item={item} />
      </TouchableOpacity>
    );
  }

  // üî• CORRECTION 8: Affichage am√©lior√© pour les tickets non-cliquables
  // console.log('‚ùå Ticket non-cliquable:', {
  //   clickable,
  //   isTicketReady: isTicketReady(),
  //   reason: !clickable ? 'Ticket non clickable (expir√©?)' : 'Ticket pas pr√™t'
  // });

  // Ticket non-cliquable ou pas encore activ√©
  return (
    <View
      style={tw`bg-white rounded-xl shadow-sm mx-4 mb-4 overflow-hidden border border-gray-100 opacity-60`}
    >
      <TicketContent item={item} />
      {/* üî• AJOUT: Indicateur pour debug */}
      {__DEV__ && (
        <View style={tw`absolute top-2 right-2 bg-red-500 rounded px-2 py-1`}>
          <Text style={tw`text-white text-xs`}>
            {!clickable ? 'Expir√©' : 'Pas pr√™t'}
          </Text>
        </View>
      )}
    </View>
  );
};

export default RenderTicket;